unit LoginService_Impl;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ This is where you are supposed to code the implementation of your objects. }
{----------------------------------------------------------------------------}
{$I DataAbstract.inc}
interface

uses
  {vcl:} Classes, SysUtils,
  {RemObjects:} uROClientIntf, uROTypes, uROServer, uROServerIntf, uROSessions, uROClasses, uRORemoteDataModule,
  {Data Abstract:} uDADataTable, uDAInterfaces, uDABusinessProcessor, uDAStreamableComponent, uDASchema, uDADelta, uDAServerInterfaces,
  {Ancestor Implementation:} SimpleLoginService_Impl,
  {Used RODLs:} DataAbstract4_Intf,
  {Generated:} sanhe_Intf
  ;

type
  { TLoginService }
  TLoginService = class(TSimpleLoginService, ILoginService)
    procedure LoginServiceLogout(Sender: TObject);
    procedure LoginServiceLogin(Sender: TObject; aUserID,
      aPassword: String; out aUserInfo: UserInfo;
      var aLoginSuccessful: Boolean);
    function LoginEx(const aLoginString: String): Boolean; override;
  private
  protected
    { ILoginService methods }
  end;

implementation

{$IFDEF DELPHIXE2UP}
{%CLASSGROUP 'System.Classes.TPersistent'}
{$ENDIF}

{$R *.dfm}
uses
  {Generated:}sanhe_Invk, fServerDataModule;

procedure Create_LoginService(out anInstance : IUnknown);
begin
  anInstance := TLoginService.Create(nil);
end;

{ LoginService }

function TLoginService.LoginEx(const aLoginString: String): Boolean;
begin
  // LoginEx infrastructure provides unified way to set additional login parameters
  // (like DomainName for Relativity)
  // Note how LoginEx string is parsed and actual login method is called
  Result := inherited LoginEx(aLoginString);
end;

procedure TLoginService.LoginServiceLogin(Sender: TObject; aUserID,
  aPassword: String; out aUserInfo: UserInfo;
  var aLoginSuccessful: Boolean);
begin
  // This is where your Login logic should be implemented. A default implementation has been added
  // for you.

  // If you application does not require sending back a UserInfo structure, you can set
  // aUserInfo to nil, indtead of returning a new instance.

  // If you require a more complex UserInfo structure (i.e. MyCompanyUserInfo), simply add
  // a new struct to the file WindowsFormsServer1.RODL and set its ancestor to UserInfo. You will then
  // be able to marshal your new custom class back to the client by reassigning the aEA.UserInfo property.

  // myInfo = new MyCompanyUserInfo();
  // myInfo.City = "London";
  // myInfo.Address = "213 Smith Road";
  // myInfo.Age = 32;
  // aUserInfo = myInfo;

  aLoginSuccessful := aUserID = aPassword;

  if aLoginSuccessful then begin
    aUserInfo := UserInfo.Create;
    aUserInfo.SessionID := GuidToString(ClientID);
    aUserInfo.UserID := aUserID;

    Session['UserID'] := aUserID;
  end
  else begin
    DestroySession;
  end;
end;

procedure TLoginService.LoginServiceLogout(Sender: TObject);
begin
  // Perform actions needed for user logout
  DestroySession;
end;

var
  fClassFactory: IROClassFactory;
initialization
  fClassFactory := TROClassFactory.Create('LoginService', Create_LoginService, TLoginService_Invoker);
finalization
  UnRegisterClassFactory(fClassFactory);
  fClassFactory := nil;
end.